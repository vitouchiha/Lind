import logging
import sys
import os
import asyncio
from aiohttp import web

# Aggiungi path corrente per import moduli
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

from services.hls_proxy import HLSProxy
from services.ffmpeg_manager import FFmpegManager
from config import PORT

# Configurazione logging (giÃ  configurata in config.py ma utile per il main)
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(name)s - %(message)s'
)

# --- Logica di Avvio ---
def create_app():
    """Crea e configura l'applicazione aiohttp."""
    # Start proxy and ffmpeg manager
    ffmpeg_manager = FFmpegManager()
    
    # Clean up any leftover processes on start
    # asyncio.create_task(ffmpeg_manager.cleanup_loop()) # Should be started in on_startup
    
    proxy = HLSProxy(ffmpeg_manager=ffmpeg_manager)
    
    app = web.Application()
    app['ffmpeg_manager'] = ffmpeg_manager # Make accessible for routes
    app.ffmpeg_manager = ffmpeg_manager # Hack for access in route handler above function
    
    # Registra le route
    app.router.add_get('/', proxy.handle_root)
    app.router.add_get('/favicon.ico', proxy.handle_favicon) # âœ… Route Favicon
    
    # âœ… Route Static Files (con path assoluto e creazione automatica)
    static_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'static')
    if not os.path.exists(static_path):
        os.makedirs(static_path)
    app.router.add_static('/static', static_path)
    
    app.router.add_get('/builder', proxy.handle_builder)
    app.router.add_get('/info', proxy.handle_info_page)
    app.router.add_get('/api/info', proxy.handle_api_info)
    app.router.add_get('/key', proxy.handle_key_request)
    app.router.add_get('/proxy/manifest.m3u8', proxy.handle_proxy_request)
    app.router.add_get('/proxy/hls/manifest.m3u8', proxy.handle_proxy_request)
    app.router.add_get('/proxy/mpd/manifest.m3u8', proxy.handle_proxy_request)
    # âœ… NUOVO: Endpoint generico per stream (compatibilitÃ  MFP)
    app.router.add_get('/proxy/stream', proxy.handle_proxy_request)
    app.router.add_get('/extractor', proxy.handle_extractor_request)
    # âœ… NUOVO: Endpoint compatibilitÃ  MFP per estrazione
    app.router.add_get('/extractor/video', proxy.handle_extractor_request)
    
    # âœ… NUOVO: Route per segmenti con estensioni corrette per compatibilitÃ  player
    app.router.add_get('/proxy/hls/segment.ts', proxy.handle_proxy_request)
    app.router.add_get('/proxy/hls/segment.m4s', proxy.handle_proxy_request)
    app.router.add_get('/proxy/hls/segment.mp4', proxy.handle_proxy_request)
    
    app.router.add_get('/playlist', proxy.handle_playlist_request)
    app.router.add_get('/segment/{segment}', proxy.handle_ts_segment)
    app.router.add_get('/decrypt/segment.mp4', proxy.handle_decrypt_segment)  # ClearKey decryption for legacy mode
    app.router.add_get('/decrypt/segment.ts', proxy.handle_decrypt_segment)   # TS variant for legacy mode
    
    # âœ… NUOVO: Route per licenze DRM (GET e POST)
    app.router.add_get('/license', proxy.handle_license_request)
    app.router.add_post('/license', proxy.handle_license_request)
    
    # âœ… NUOVO: Endpoint per generazione URL (compatibilitÃ  MFP)
    app.router.add_post('/generate_urls', proxy.handle_generate_urls)

    # --- PROXY ROUTES GENERICI ---
    async def proxy_hls_stream(request):
        """Serve segments generated by FFmpeg"""
        stream_id = request.match_info['stream_id']
        filename = request.match_info['filename']
        
        file_path = os.path.join("temp_hls", stream_id, filename)
        
        # Security check: ensure path is within temp_hls
        try:
            if not os.path.abspath(file_path).startswith(os.path.abspath("temp_hls")):
                 return web.Response(status=403, text="Access denied")
        except:
            return web.Response(status=403, text="Access denied")

        if not os.path.exists(file_path):
            return web.Response(status=404, text="Segment not found")
            
        # Notify manager to keep stream alive
        if hasattr(app, 'ffmpeg_manager'):
             app.ffmpeg_manager.touch_stream(stream_id)
        
        if not os.path.exists(file_path):
            return web.Response(status=404, text="Segment not found")
            
        # Notify manager to keep stream alive
        if hasattr(app, 'ffmpeg_manager'):
             app.ffmpeg_manager.touch_stream(stream_id)
        
        headers = {
            "Access-Control-Allow-Origin": "*",
            "Access-Control-Allow-Methods": "GET, HEAD, OPTIONS",
            "Access-Control-Allow-Headers": "*",
            "Cache-Control": "no-cache, no-store, must-revalidate",
            "Connection": "keep-alive"
        }

        # Special handling for m3u8: read content and return 200 OK (no Range)
        if filename.endswith('.m3u8'):
            try:
                # Add a small delay/retry read loop if file is being written?
                # Usually OS allows reading while writing, but empty file is possible.
                content = ""
                for _ in range(3):
                    with open(file_path, 'r', encoding='utf-8') as f:
                        content = f.read()
                    if content:
                        break
                    await asyncio.sleep(0.05)
                
                return web.Response(
                    text=content,
                    content_type='application/vnd.apple.mpegurl',
                    headers=headers
                )
            except Exception as e:
                logging.error(f"Error reading playlist {file_path}: {e}")
                return web.Response(status=500, text="Internal Server Error")
        
        elif filename.endswith('.ts'):
            # For segments, correct mime type
            # We can still use FileResponse for efficiency, usually players handle range or 206 for segments fine.
            # But let's force expected headers.
            # aiohttp FileResponse handles ranges automatically. 
            pass
            
        # web.FileResponse doesn't easily allow overriding headers in constructor in older versions,
        # but we can set them on the response object if we create it differently or subclass.
        # Actually, standard FileResponse takes headers.
        
        # Explicit content type for TS
        if filename.endswith('.ts'):
             # Create response, add headers, then prepare? No, FileResponse is unexpected.
             # Just pass headers.
             headers['Content-Type'] = 'video/MP2T'
             return web.FileResponse(file_path, headers=headers)
        
        return web.FileResponse(file_path, headers=headers)

    app.router.add_get('/ffmpeg_stream/{stream_id}/{filename}', proxy_hls_stream)

    # âœ… NUOVO: Endpoint per ottenere l'IP pubblico
    app.router.add_get('/proxy/ip', proxy.handle_proxy_ip)
    
    # Gestore OPTIONS generico per CORS
    app.router.add_route('OPTIONS', '/{tail:.*}', proxy.handle_options)
    
    async def cleanup_handler(app):
        await proxy.cleanup()
    app.on_cleanup.append(cleanup_handler)
    
    async def on_startup(app):
        asyncio.create_task(ffmpeg_manager.cleanup_loop())
    app.on_startup.append(on_startup)
    
    return app

# Crea l'istanza "privata" dell'applicazione aiohttp.
app = create_app()

def main():
    """Funzione principale per avviare il server."""
    # Workaround per il bug di asyncio su Windows con ConnectionResetError
    if sys.platform == 'win32':
        # Silenzia il logger di asyncio per evitare spam di ConnectionResetError
        logging.getLogger('asyncio').setLevel(logging.CRITICAL)

    print("ðŸš€ Avvio HLS Proxy Server...")
    print(f"ðŸ“¡ Server disponibile su: http://localhost:{PORT}")
    print(f"ðŸ“¡ Oppure: http://server-ip:{PORT}")
    print("ðŸ”— Endpoints:")
    print("   â€¢ / - Pagina principale")
    print("   â€¢ /builder - Interfaccia web per il builder di playlist")
    print("   â€¢ /info - Pagina con informazioni sul server")
    print("   â€¢ /proxy/manifest.m3u8?url=<URL> - Proxy principale per stream")
    print("   â€¢ /playlist?url=<definizioni> - Generatore di playlist")
    print("=" * 50)
    
    web.run_app(
        app, # Usa l'istanza aiohttp originale per il runner integrato
        host='0.0.0.0',
        port=PORT
    )

if __name__ == '__main__':
    main()